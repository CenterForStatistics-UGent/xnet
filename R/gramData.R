#' Constructors for gramData objects
#'
#' These functions can be used to manually construct objects from the \code{\link[xnet:dataClasses]{gramData classes}} for use in \code{\link{tskrr}} objects.
#'
#' When constructing a \code{gramData} object from a \code{data.frame}, you can either specify a conversion function yourself, or use a kernel from the package \code{kernlab}. If you select one of these kernels, the data frame is first converted to a model matrix according to the specified formula (see \code{\link[stats]{model.matrix}}). On this matrix, the chosen kernel is then applied. By default, a linear kernel is used on a model with all variables as main effect and without intercept.
#'
#' @param x an object to be converted to a \code{gramData} object
#' @param conversion a conversion function or a formula specifying which variables should be used to be converted. See Details
#' @param conv.args a named list with extra arguments passed to the conversion function.
#' @param keep.gram a logical value indicating whether the gram matrix should be kept or not.
#' @param kernel a kernel generating function from the package \code{\link[kernlab:dots]{kernlab}}. See details.
#' @param kernel.args a list with further arguments to be passed to \code{kernel}.
#' @param labels an optional character vector with the labels for the observations. If \code{x} is a matrix with row- and/or columnames and no labels are given, the function will check whether row- and columnames are the same, and if so, use those as labels.
#' @param scale a logical value indicating whether the model matrix needs to be scaled before applying the kernel. It defaults to \code{TRUE}. This will store the centers and standard deviations for use in predictions later on.
#' @param na.action how \code{NA}s are treated. Defaults to \code{\link[stats:na.fail]{na.fail}}. Takes either a character value or a function.
#' @param which a character value indicating whether the \code{gramData} oject for the rows or the columns should be extracted from the \code{\link{tskrr}} object.
#' @param ... arguments passed to other methods.
#'
#' @seealso \code{\link{dataClasses}} for an overview of the different classes generated by these functions.
#'
#' @examples
#'
#' # Construct from a data frame
#' adf <- data.frame(
#'   a = c(4,1,2,4,5),
#'   b = c(5,4,3,2,1),
#'   c = c(1,5,2,4,3)
#' )
#'
#' g <- gramData(adf)
#'
#' conv <- function(x){
#'   tcrossprod(as.matrix(x))
#' }
#' gm <- gramData(adf, conversion = conv, keep.gram = TRUE)
#'
#' # Construct from a matrix
#' adm <- as.matrix(adf)
#' m <- conv(adf)
#' gm2 <- gramData(m)
#' gm3 <- gramData(adm, conv,
#'                 keep.gram = TRUE)
#'
#' # Construct from a formula
#' # Don't forget to remove the intercept, otherwise
#' # you can't perform the eigen decomposition.
#' gm4 <- gramData(adf, ~ a + b - 1)
#'
#' @include all_generics.R
#'
#' @importFrom stats model.matrix as.formula model.matrix.lm
#' @importFrom kernlab kernelMatrix vanilladot
#'
#' @rdname gramData
#' @name gramData
#' @aliases gramData,data.frame,function-method
#'
#' @export
setMethod("gramData",
          c("data.frame", "function"),
          function(x, conversion,
                   conv.args = list(),
                   keep.gram = FALSE,
                   labels = character(0)){
            new("gramDataFrame",
                orig = x,
                conversion = conversion,
                conv.args = conv.args,
                hasgram = keep.gram,
                labels = labels)
          })


#' @rdname gramData
#' @export
setMethod("gramData",
          c("data.frame", "ANY"),
          function(x, conversion, kernel = vanilladot,
                   kernel.args = list(),
                   keep.gram = FALSE,
                   labels = character(0),
                   scale = TRUE,
                   na.action = "na.fail"){
            # Sanity check
            if(missing(conversion)){
              conversion <- as.formula("~ . -1")
            }
            if(!inherits(conversion, "formula")){
              stop("Conversion needs to be a function or a formula.")
            }

            # Construct kernelfunction
            kernel <- match.fun(kernel)
            kf <- do.call(kernel, kernel.args)

            # take the scaling
            if(scale){
              m <- model.matrix.lm(conversion,x,
                                   na.action = na.action)
              mx <- scale(m)
              centers <- attr(mx, "scaled:center")
              sigma <- attr(mx, "scaled:scale")

            } else {
              centers <- 1
              sigma <- 1
            }

            convfun <- function(dframe){
              mm <- model.matrix.lm(conversion, dframe,
                                    na.action = na.action)
              if(scale) {
                for(i in seq_len(nrow(mm)))
                  mm[i,] <- (mm[i,] - centers) / sigma
              }
              # only model.matrix.lm acknowledges the
              kernelMatrix(kf,mm)
            }

            new("gramDataFrame",
                orig = x,
                conversion = convfun,
                hasgram = keep.gram,
                labels = labels)
          })
#----------------------------
# Function for matrices

.find_labels_in_matrix <- function(x){
  rn <- rownames(x)
  cn <- colnames(x)
  if(!is.null(rn) && !is.null(cn)){
    if(all(rn == cn))
      return(rn)
    else
      stop("row- and columnames differ.")
  } else if(is.null(rn) && !is.null(cn)){
    return(cn)
  } else if(is.null(cn) && !is.null(rn)){
    return(rn)
  } else {
    return(character(0))
  }
}

#' @rdname gramData
#' @export
setMethod("gramData",
          c("matrix","function"),
          function(x, conversion,
                   conv.args = list(),
                   keep.gram = FALSE,
                   labels = character(0)){
            if(length(labels) == 0){
              labels <- .find_labels_in_matrix(x)
            }
              new("gramDataMatrix",
                  orig = x,
                  conversion = conversion,
                  conv.args = conv.args,
                  hasgram = keep.gram,
                  labels = labels)
          })

#' @rdname gramData
#' @export
setMethod("gramData",
          c("matrix","missing"),
          function(x, conversion, keep.gram = FALSE,
                   labels = character(0)){
            if(length(labels) == 0){
              labels <- .find_labels_in_matrix(x)
            }
            new("gramData",
                gram = x,
                hasgram = keep.gram,
                labels = labels
                )
          })


#' @rdname gramData
#' @export
setMethod("gramData",
          "tskrr",
          function(x, which = c("row","column")){
  id <- match.arg(which)
  if(is_homogeneous(x) || id == "row"){
    x@k
  } else {
    x@g
  }
          })
