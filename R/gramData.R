#' Constructors for gramData objects
#'
#' These functions can be used to manually construct objects from the \code{\link[=dataClasses]{gramData classes}} for use in \code{\link{tskrr}} objects.
#'
#' When constructing a \code{gramData} object from a \code{data.frame}, you can either specify a conversion function yourself, or use a kernel from the package \code{kernlab}. If you select one of these kernels, the data frame is first converted to a model matrix according to the specified formula (see \code{\link[stats]{model.matrix}}). On this matrix, the chosen kernel is then applied. By default, a Gaussian RBF kernel with \code{sigma = 1} is used on a model matrix formed by all variables and without an intercept.
#'
#' @param x an object to be converted to an \code{adjacencyData} or \code{gramData} object
#' @param conversion a conversion function or a formula specifying which variables should be used to be converted. See Details
#' @param keep.gram a logical value indicating whether the gram matrix should be kept or not.
#' @param kernel a kernel generating function from the package \code{\link[kernlab:dots]{kernlab}}. See details.
#' @param kernel.args a list with further arguments to be passed to \code{kernel}.
#' @param ... arguments passed to other methods.
#'
#' @seealso \code{\link{dataClasses}} for an overview of the different classes generated by these functions.
#'
#' @include all_generics.R
#'
#' @importFrom stats model.matrix as.formula
#' @importFrom kernlab kernelMatrix rbfdot
#'
#' @rdname gramData
#' @name gramData
#' @aliases gramData,data.frame,function-method
#'
#' @export
setMethod("gramData",
          c("data.frame", "function"),
          function(x, conversion, keep.gram = FALSE){
            new("gramDataFrame",
                orig = x,
                conversion = conversion,
                keep.gram = keep.gram)
          })


#' @rdname gramData
#' @export
setMethod("gramData",
          c("data.frame", "ANY"),
          function(x, conversion, kernel = rbfdot,
                   kernel.args = list(),
                   keep.gram = FALSE){
            # Sanity check
            if(missing(conversion)){
              conversion <- as.formula("~ . -1")
            }
            if(!inherits(conversion, "formula")){
              stop("Conversion needs to be a formula.")
            }

            convfun <- function(dframe){
              mm <- model.matrix(conversion, dframe)
              kf <- do.call(kernel, kernel.args)
              kernelMatrix(kf,mm)
            }

            new("gramDataFrame",
                orig = x,
                conversion = convfun,
                keep.gram = keep.gram)
          })
