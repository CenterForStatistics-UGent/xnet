#' Constructors for gramData objects
#'
#' These functions can be used to manually construct objects from the \code{\link[xnet:dataClasses]{gramData classes}} for use in \code{\link{tskrr}} objects.
#'
#' When constructing a \code{gramData} object from a \code{data.frame}, you can either specify a conversion function yourself, or use a kernel from the package \code{kernlab}. If you select one of these kernels, the data frame is first converted to a model matrix according to the specified formula (see \code{\link[stats]{model.matrix}}). On this matrix, the chosen kernel is then applied. By default, a Gaussian RBF kernel with \code{sigma = 1} is used on a model matrix formed by all variables and without an intercept.
#'
#'
#' @param x an object to be converted to a \code{gramData} object
#' @param conversion a conversion function or a formula specifying which variables should be used to be converted. See Details
#' @param conv.args a named list with extra arguments passed to the conversion function.
#' @param keep.gram a logical value indicating whether the gram matrix should be kept or not.
#' @param kernel a kernel generating function from the package \code{\link[kernlab:dots]{kernlab}}. See details.
#' @param kernel.args a list with further arguments to be passed to \code{kernel}.
#' @param labels an optional character vector with the labels for the observations. If \code{x} is a matrix with row- and/or columnames and no labels are given, the function will check whether row- and columnames are the same, and if so, use those as labels.
#' @param ... arguments passed to other methods.
#'
#' @seealso \code{\link{dataClasses}} for an overview of the different classes generated by these functions.
#'
#' @examples
#'
#' # Construct from a data frame
#' adf <- data.frame(
#'   a = c(4,1,2,4,5),
#'   b = c(5,4,3,2,1),
#'   c = c(1,5,2,4,3)
#' )
#'
#' g <- gramData(adf)
#'
#' conv <- function(x){
#'   tcrossprod(as.matrix(x))
#' }
#' gm <- gramData(adf, conversion = conv, keep.gram = TRUE)
#'
#' # Construct from a matrix
#' adm <- as.matrix(adf)
#' m <- conv(adf)
#' gm2 <- gramData(m)
#' gm3 <- gramData(adm, conv,
#'                 keep.gram = TRUE)
#'
#' # Construct from a formula
#' # Take all variables and remove the intercept
#' gm4 <- gramData(adf, ~ a + b)
#'
#' @include all_generics.R
#'
#' @importFrom stats model.matrix as.formula
#' @importFrom kernlab kernelMatrix rbfdot
#'
#' @rdname gramData
#' @name gramData
#' @aliases gramData,data.frame,function-method
#'
#' @export
setMethod("gramData",
          c("data.frame", "function"),
          function(x, conversion,
                   conv.args = list(),
                   keep.gram = FALSE,
                   labels = character(0)){
            new("gramDataFrame",
                orig = x,
                conversion = conversion,
                conv.args = conv.args,
                hasgram = keep.gram,
                labels = labels)
          })


#' @rdname gramData
#' @export
setMethod("gramData",
          c("data.frame", "formula"),
          function(x, conversion, kernel = rbfdot,
                   kernel.args = list(),
                   keep.gram = FALSE,
                   labels = character(0)){
            # Sanity check
            if(missing(conversion)){
              conversion <- as.formula("~ . -1")
            }
            if(!inherits(conversion, "formula")){
              stop("Conversion needs to be a function or a formula.")
            }

            convfun <- function(dframe){
              mm <- model.matrix(conversion, dframe)
              kf <- do.call(kernel, kernel.args)
              kernelMatrix(kf,mm)
            }

            new("gramDataFrame",
                orig = x,
                conversion = convfun,
                hasgram = keep.gram,
                labels = labels)
          })
#----------------------------
# Function for matrices

.find_labels_in_matrix <- function(x){
  rn <- rownames(x)
  cn <- colnames(x)
  if(!is.null(rn) && !is.null(cn)){
    if(all(rn == cn))
      return(rn)
    else
      stop("row- and columnames differ.")
  } else if(is.null(rn) && !is.null(cn)){
    return(cn)
  } else if(is.null(cn) && !is.null(rn)){
    return(rn)
  } else {
    return(character(0))
  }
}

#' @rdname gramData
#' @export
setMethod("gramData",
          c("matrix","function"),
          function(x, conversion,
                   conv.args = list(),
                   keep.gram = FALSE,
                   labels = character(0)){
            if(length(labels) == 0){
              labels <- .find_labels_in_matrix(x)
            }
              new("gramDataMatrix",
                  orig = x,
                  conversion = conversion,
                  conv.args = conv.args,
                  hasgram = keep.gram,
                  labels = labels)
          })

#' @rdname gramData
#' @export
setMethod("gramData",
          c("matrix","missing"),
          function(x, conversion, keep.gram = FALSE,
                   labels = character(0)){
            if(length(labels) == 0){
              labels <- .find_labels_in_matrix(x)
            }
            new("gramData",
                gram = x,
                hasgram = keep.gram,
                labels = labels
                )
          })
