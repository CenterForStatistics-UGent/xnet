% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/all_generics.R, R/gramData.R
\name{gramData}
\alias{gramData}
\alias{gramData,data.frame,function-method}
\alias{gramData,data.frame,ANY-method}
\alias{gramData,matrix,function-method}
\alias{gramData,matrix,missing-method}
\title{#' Constructors for gramData objects}
\usage{
gramData(x, conversion, ...)

\S4method{gramData}{data.frame,`function`}(
  x,
  conversion,
  conv.args = list(),
  keep.gram = FALSE,
  labels = character(0)
)

\S4method{gramData}{data.frame,ANY}(
  x,
  conversion,
  kernel = rbfdot,
  kernel.args = list(),
  keep.gram = FALSE,
  labels = character(0)
)

\S4method{gramData}{matrix,`function`}(
  x,
  conversion,
  conv.args = list(),
  keep.gram = FALSE,
  labels = character(0)
)

\S4method{gramData}{matrix,missing}(x, conversion, keep.gram = FALSE, labels = character(0))
}
\arguments{
\item{x}{an object to be converted to a \code{gramData} object}

\item{conversion}{a conversion function or a formula specifying which variables should be used to be converted. See Details}

\item{...}{arguments passed to other methods.}

\item{conv.args}{a named list with extra arguments passed to the conversion function.}

\item{keep.gram}{a logical value indicating whether the gram matrix should be kept or not.}

\item{labels}{an optional character vector with the labels for the observations. If \code{x} is a matrix with row- and/or columnames and no labels are given, the function will check whether row- and columnames are the same, and if so, use those as labels.}

\item{kernel}{a kernel generating function from the package \code{\link[kernlab:dots]{kernlab}}. See details.}

\item{kernel.args}{a list with further arguments to be passed to \code{kernel}.}
}
\description{
These functions can be used to manually construct objects from the \code{\link[xnet:dataClasses]{gramData classes}} for use in \code{\link{tskrr}} objects.
}
\details{
When constructing a \code{gramData} object from a \code{data.frame}, you can either specify a conversion function yourself, or use a kernel from the package \code{kernlab}. If you select one of these kernels, the data frame is first converted to a model matrix according to the specified formula (see \code{\link[stats]{model.matrix}}). On this matrix, the chosen kernel is then applied. By default, a Gaussian RBF kernel with \code{sigma = 1} is used on a model matrix formed by all variables and without an intercept.
}
\examples{

# Construct from a data frame
adf <- data.frame(
  a = c(4,1,2,4,5),
  b = c(5,4,3,2,1),
  c = c(1,5,2,4,3)
)

g <- gramData(adf)

conv <- function(x){
  tcrossprod(as.matrix(x))
}
gm <- gramData(adf, conversion = conv, keep.gram = TRUE)

# Construct from a matrix
adm <- as.matrix(adf)
m <- conv(adf)
gm2 <- gramData(m)
gm3 <- gramData(adm, conv,
                keep.gram = TRUE)

}
\seealso{
\code{\link{dataClasses}} for an overview of the different classes generated by these functions.
}
